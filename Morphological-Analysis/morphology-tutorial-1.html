<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="Morphology Tutorial, Part I,Morphology Tutorial, Part II" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <title>Morphology Tutorial: Part I - NLP Course Wiki</title>
    <style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "/~tkt_plus/nlp-wiki/skins/monobook/main.css?9"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="/~tkt_plus/nlp-wiki/skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "/~tkt_plus/nlp-wiki/skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "/~tkt_plus/nlp-wiki/skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "/~tkt_plus/nlp-wiki/skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE 7]><style type="text/css">@import "/~tkt_plus/nlp-wiki/skins/monobook/IE70Fixes.css?1";</style><![endif]-->
    <!--[if lt IE 7]><script type="text/javascript" src="/~tkt_plus/nlp-wiki/skins/common/IEFixes.js"></script>
	<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript">var skin = 'monobook';var stylepath = '/~tkt_plus/nlp-wiki/skins';</script>
    <script type="text/javascript" src="/~tkt_plus/nlp-wiki/skins/common/wikibits.js?1"><!-- wikibits js --></script>
    <script type="text/javascript" src="/~tkt_plus/nlp-wiki/index.php?title=-&amp;action=raw&amp;smaxage=0&amp;gen=js"><!-- site js --></script>
    <style type="text/css">/*<![CDATA[*/
@import "/~tkt_plus/nlp-wiki/index.php?title=MediaWiki:Common.css&action=raw&ctype=text/css&smaxage=18000";
@import "/~tkt_plus/nlp-wiki/index.php?title=MediaWiki:Monobook.css&action=raw&ctype=text/css&smaxage=18000";
@import "/~tkt_plus/nlp-wiki/index.php?title=-&action=raw&gen=css&maxage=18000";
/*]]>*/</style>
    <!-- Head Scripts -->
  </head>
  <body  class="ns-0 ltr">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="top"></a>
	  <h1 class="firstHeading">Morphology Tutorial: Part I</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From NLP Course Wiki</h3>
	    <div id="contentSub"></div>
	    <div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
	    <p>(<i>Roman Yangarber, University of Helsinki, 2016-2021</i>)
            </p><p>In class, we introduced the tools you'll need for this assignment and project:
            </p><p><b>HFST</b>
            </p><p>The tools are installed from the resource repositories, found under:
            </p>
            <pre>
              http://www.ling.helsinki.fi/kieliteknologia/tutkimus/hfst/index.shtml
              https://github.com/hfst/hfst/wiki/Download-And-Install
            </pre>
            <!-- /fs-1/f/tkt_plus/nlp/Morphology/ -->
            <p>The small example grammars we developed in class are under the
            directories/folders <b>Finnish-00/, Finnish-01/, ...</b>

            </p><p>For further information on making rules, please see <b>HFST</b> manual
            in the repository.
            </p
>
            <hr/>
            <h3>Tool setup</h3>
            
            <p> You can either find an executable distribution from the HFST site, or
              download the source and compile it according to the download + install
              instructions for your platform (Linux, MacOS, Windows, etc.).

              <br />

              We will create two kinds of files:
            <ul>
              <li /><b>finnish.lexc</b> will contain the lexicons, e.g., the Noun and Verb
              lexicons,
              <li /><b>finnish.twol</b> will contain the two-level rules.
            </ul>
            All resulting transducer files will have an extension <b>.hfst</b>.
            You will need at least the following HFST tools to work:
            <ul>
              <li /><b>hfst-lexc</b>: to compile your lexicon into a transducer.
              <li /><b>hfst-twolc</b>: to compile your rules into a transducer.

              <li /><b>hfst-compose-intersect</b>: to intersect the rules, and compose
              them with lexicon &mdash; the complete transducer.  Note, the resulting
              transducer will be a <b>generator</b>.

              <li /><b>hfst-invert</b>: to flip the tapes: to convert the generator to an
              analyzer.

            </ul>
            You can also use these <i>optional</i> tools:
            <ul>
              <li /><b>hfst-fst2fst</b>: to optimize your analyzer (for faster access).
              <li /><b>hfst-fst2strings</b>: for debugging: to produce <b>all</b> possible
              strings that your analyzer will recognize.

              <li /><b>hfst-fst2txt</b>: to use with the supplied python scripts (which
              are in the scripts/ folder) to produce graphs of the analyzer at the
              detailed character level.
            </ul>

            <p>
              The last command &mdash; <b>hfst-lookup</b> &mdash; takes an analyzer and
              allows you to type in words one at a time to be analyzed.  

              <br />

              (It also works with a generator: you give the lexical forms, and it
              generates the words.)

              <br />

              To run the optimized analyzer use this command in shell:
              <pre>
                hfst-lookup finnish-analyzer.hfstol
              </pre>
            </p>

            To make using these tools much easier, you have a <b>makefile</b> in each
            example directory.  This lets you to use simple commands from a command shell:

            <ul>
              <li /><b>make</b>: compiles everything.

              <li /><b>make check</b>: prints out all strings recognized by the
              transducer.  

              <li /><b>make graph-FST</b>: creates a high-level picture (.png) of the
              transducer.

              <li /><b>make graph-characters</b>: creates a low-level, very detailed
              picture of the transducer.

            </ul>

            <br />
              
            <hr />

            <table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
                  <ul>
                    <li class="toclevel-1"><a href="#A_Brief_Tutorial_on_Two-Level_Morphology.2C_Using_HFST"><span class="tocnumber"> </span> <span class="toctext">A Brief Tutorial on Two-Level Morphology, Using HFST</span></a></li>
                    <li class="toclevel-1"><a href="#Basic_setup"><span class="tocnumber"> </span> <span class="toctext">Basic grammar (00)</span></a></li>
                    <li class="toclevel-1"><a href="#Vowel_Harmony_.2801.29"><span class="tocnumber"> </span> <span class="toctext">Vowel Harmony (01)</span></a></li>
                    <li class="toclevel-1"><a href="#From Rule to Transducer"><span class="tocnumber"> </span> <span class="toctext">From Rule to Transducer: Examine the transducer</span></a></li>
                    <li class="toclevel-1"><a href="#Morphological_Rules_.2802.29"><span class="tocnumber"> </span> <span class="toctext">Morphological Rules (02)</span></a></li>
                    <li class="toclevel-1"><a href="#HFST Rule Notation"><span class="tocnumber"> </span> <span class="toctext">HFST Rule Notation</span></a></li>
                    <li class="toclevel-1"><a href="#Improving_the_rule_.28.2A.2A.2A.29"><span class="tocnumber"> </span> <span class="toctext">Improving the rule (***)</span></a></li>
                    <li class="toclevel-1"><a href="#Illative_case:_vowel_doubling_.2803.29"><span class="tocnumber"> </span> <span class="toctext">Illative case: vowel doubling (03)</span></a></li>
                    <li class="toclevel-1"><a href="#Batch_testing_and_validation"><span class="tocnumber"> </span> <span class="toctext">Batch testing and validation</span></a></li>
                    <li class="toclevel-1"><a href="#Final_-i.2F-e-_alternation_in_nouns_.2804.29"><span class="tocnumber"> </span> <span class="toctext">Final -i/-e- alternation in nouns (04)</span></a></li>
                    <li class="toclevel-1"><a href="#Consonant_Gradation:_tt-.3Et_.2805.29"><span class="tocnumber"> </span> <span class="toctext">Consonant Gradation: tt → t (05)</span></a></li>
                    <li class="toclevel-1"><a href="#Relaxing_the_rule_.28.2A.2A.2A.29"><span class="tocnumber"> </span> <span class="toctext">Relaxing the rule (***)</span></a></li>
                    <li class="toclevel-1"><a href="#Weakening_t-.3Ed_.2806.29"><span class="tocnumber"> </span> <span class="toctext">Weakening t → d (06)</span></a></li>
                    <li class="toclevel-1"><a href="#Left_for_the_reader"><span class="tocnumber"> </span> <span class="toctext">Left for the reader</span></a></li>
                    <li class="toclevel-1"><a href="#Closing_Note"><span class="tocnumber"> </span> <span class="toctext">Closing Note</span></a></li>
                  </ul>
            </td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>

            <br />
            <hr />

            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=1" title="Edit section: A Brief Tutorial on Two-Level Morphology, Using HFST"></a>]</div><a name="A_Brief_Tutorial_on_Two-Level_Morphology.2C_Using_HFST"></a><h2> A Brief Tutorial on Two-Level Morphology, Using HFST </h2>
            <p>Note: this tutorial is not a complete reference, It is intended only to
            give the student an introduction into designing a morphological grammar using
            Two-Level morphology.
            </p><p>In this tutorial we will go through the basic steps, starting with a
            simple lexicon and creating more complex lexicons and adding rules.
            </p><p>The resulting setups for HFST are in the course repository, under the
            directories called <b>Finnish-*/</b>
            </p><p>The sections marked by <b>(***)</b> are somewhat more advanced, and may
            be skipped on first reading.  (They will be useful later, if you decide to do
            the project on morphology, or some of the extra-credit assignments.)
            </p>

            <br />
            <hr />

            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=2" title="Edit section: Basic setup (00)"></a>]</div><a name="Basic_setup"></a><h2> Basic grammar (00) </h2>
            <ul><li> Begin with defining morphotactics: in <b>finnish.lexc</b> construct a
            basic lexicon, consisting of "simple" nouns (<b>Noun-stems lexicon</b>) and
            verbs (<b>Verb-stems lexicon</b>), and their inflectional paradigms
            (<b>Noun-Infl-I</b> and <B>Verb-Infl-I</b>).  These words do not need any
            morpho-phonological changes, so the rule file has no rules.
            </li></ul>
            <pre>
              nouns: talo, savu
              verbs: palaa, ajaa
            </pre>
            <p>For nouns we consider several cases, in the singular number (excluding
            partitive and illative case).  For verbs we consider only the present tense
            (excluding 3rd person singular for now).
            </p><p>Currently, our lexicon has a very simple structure.
            </p>
            <img src="./Finnish-00/finnish.lexc.png"
                 alt="Image:Pictures-simple-lex-1.jpg" width="590"
                 />
            <p>The names in the oval nodes are the names of the <i>sub-lexicons</i>,
            as defined in the <b>*.lexc</b> files.  For example, the
            file <b>finnish.lexc</b> contains
            </p>
            <ul><li> all noun stems that belong to the <b>Noun-stems</b> sublexicon
              </li><li> all morphemes that belong to the <b>Noun-Infl-I</b> sub-lexicon, basic case endings for nouns (and adjectives!)
              </li><li> all verb stems that belong to the <b>Verb-stems</b> sublexicon
              </li><li> all morphemes that belong to the <b>Verb-Infl-I</b> sub-lexicon,
              for person and number in the present tense,
              </li><li> two special sub-lexicons <b>Root</b> and <b>#</b> &mdash; the
              initial and final states of the automaton.
            </li></ul>
            <!-- A continuation class is the <i>sets of arcs</i> that leaves one (or more)
            lexicon node.  Thus, for example, the pair of arcs leaving the <b>INITIAL</b>
            node make up the <b>Begin</b> continuation class in the main lexicon
            file, <b>finnish.lex</b>; the set consisting of just one arc leaving
            the <b>NOUN-I</b> node is called the <b>NounSuff</b> continuation class, etc.
            Note that the same continuation class may be used by several different
            sub-lexicons; in our simple lexicon model, the <b>End</b> continuation class
            is shared both by <b>NOUN-I</b> and by <b>VERB-I</b>.
              <a href="/~tkt_plus/nlp-wiki/index.php?title=Image:Pictures-simple-lex-cont-class-1.jpg"
              class="image"
              title="Image:Pictures-simple-lex-cont-class-1.jpg"><img src="/%7Etkt_plus/nlp-wiki/images/0/00/Pictures-simple-lex-cont-class-1.jpg"
              alt="Image:Pictures-simple-lex-cont-class-1.jpg" width="894" height="275"
              longdesc="/~tkt_plus/nlp-wiki/index.php?title=Image:Pictures-simple-lex-cont-class-1.jpg"
              /></a> -->
            </p><p>By convention, lexicons names are Capitalized.  <b>Root</b> is a
            special keyword in <b>HFST</b>.  It identifies the <b>main</b> LEXICON, so we
            cannot use it, e.g., as the name of another lexicon.
            <!--
            This simple graph is represented
              in <b>HFST</b> lexicon format as follows:
            </p>
            <pre>;           NAME:           COMPRISING SUBLEXICONS:
              ;           ----            ----------------------
              ALTERNATION Begin           NOUN-I  VERB-I
              ALTERNATION NounSuff        CASE
              ALTERNATION VerbSuff        PERSONNUM
              ALTERNATION End             FINAL
            </pre>
              -->
            <p>This lexicon structure will suffice for the first part of the tutorial.  It
            will be extended in <a href="./morphology-tutorial-2.html" title="Morphology
            Tutorial, Part II">Morphology Tutorial, Part II</a>.
            </p><p>Since there are no morpho-phonological alternations for these word
              forms, we don't need any rules, and the <b>rule</b> file has no rules.
              <!-- and we use a <b>finnish.rul</b> file, directly fed into <b>HFST,</b>
              containing just the default rules. -->
            </p><p>This grammar is in directory <b>Finnish-00/</b>.
            </p>


            <br />
            <hr />

            <div class="editsection"
            style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=3"
            title="Edit section: Vowel Harmony
            (01)"></a>]</div><a name="Vowel_Harmony_.2801.29"></a><h2> Vowel Harmony
            (01) </h2>
            <ul><li> Add nouns and verbs to lexicon that contain front vowels (no back
            vowels)
            </li></ul>
            <pre>
              nouns: isä, hissi
              verbs: kysyä, kestää
            </pre>
          <p>The simplest and most trivial way to handle these new words is through the
              lexicon: we could simply add another noun class (<b>Noun-Infl-FR</b>) and
              another verb class (<b>Verb-Infl-FR</b>) to the lexicon, to cover nouns and
              verbs that contain only front vowels, and add inflection lexicons for them.
            </p>
            <img src="./Finnish-01/finnish.lexc.png" alt="Image:Pictures-simple-lex-1.jpg"
                 width="590" />
          <p>Note, that we can produce this graph by running the command:
          </p>
          <pre>
            make graph-FST
          </pre>
          <p>We can also produce a completely detailed, character-level graph of the
          entire transducer by running the command:
          </p>
          <pre>
            make graph-characters
          </pre>

          <p>We would still not need to use any rules.
          </p><p>The resulting grammar is in directory <b>Finnish-01/</b>.
            </p><p>Note that this requires changes to the all lexicons (with the
            exception of the <b>Root</b>, which does not change).
            </p><p>However, this is highly inefficient:
            </p>
            <ul><li> the endings in <b>Noun-Infl-I</b> and <b>Noun-Infl-FR</b> have a
                great deal of overlap,
              </li><li> the entries for the verbs differ only is in the infinitive and
                3rd person plural (<b>vat/vät</b>).
              </li><li> this approach results in <i>MULTIPLYING OUT</i> the cases: we will
                quickly end up with huge lexicons, which are mostly redundant.
            </li></ul>
            <p>To see what we mean by <i>multiplying out</i>, consider what would happen
              if we used the same approach to handle consonant gradation, which we will do
              in the next section, for grade weakening <b>tt → t</b> in some positions,
              like <b>katto</b> (nominative)/<b>katon</b> (genitive).  If we use the same
              approach, i.e., create a new class for nouns that have strong
              grade <b>-tt-</b> in their stems, which goes to weak grade <b>-t-</b>, we
              would now need 4 classes:
            </p>
            <ul><li> nouns with strong grade and back vowels in stem,
              </li><li> nouns with strong grade and no back vowels in stem, 
              </li><li> nouns with weak grade and back vowels in stem, 
              </li><li> nouns with weak grade and no back vowels in stem, 
            </li></ul>
            <p>i.e., 2 x 2 separate classes just for nouns (and another 4 for the verbs),
            which are very similar.
            </p>

            <br />
            <hr />

            <div class="editsection"
            style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=4"
            title="Edit section: Morphological Rules
            (02)"></a>]</div><a name="Morphological_Rules_.2802.29"></a><h2>
            Morphological Rules (02) </h2>
            <p>A more clever approash is:
            </p>
            <ul><li> Add <b>morpho-phonological</b> rules to handle vowel harmony.
            </li></ul>
            <p>This will allow us to keep the inflectional lexicons for nouns and verbs
            free of repetition, and specify only when the original (back) vowels in the
            ending morphemes need to be changed to front vowels.  Important: this will
            work for <i>both</i> nouns <i>and</i> verbs.
            </p><p>This requires a <b>two-level</b> rule.  How do we know what rule to
              write?
          </p><p> We need to add three feasible pairs to the
              alphabet: <b>a:ä</b>, <b>o:ö</b>, <b>u:y</b>.  Note that the colon separates
              between the symbols on the two tapes.  Note also that in writing the rules,
              the colon may be omitted on either side (or both side) which means
              that <b>ANY</b> symbol can occur there.
          </p><p>
              
              We observe that &mdash; for our current lexicon of nouns and verbs &mdash;
              if we have a back vowel, from the set <b>Vback</b>, it changes
              to a front vowel, in <b>Vfront</b>, if and only if:
            </p>
            <ul><li> it is in the <b>suffix</b> &mdash; i.e., there was a morpheme
                boundary <b>+:0</b> preceding the place of the change; and
              </li>
              
              <li> prior to the morpheme boundary &mdash; i.e., in the <i>stem</i> of the
                noun or verb &mdash; <i>NO</i> back vowels were encountered on the input:
                only consonants, front vowels, or neutral vowels (as in <b>hissi</b>) were
                observed in the stem &mdash; from the beginning of the word up to the
                morpheme boundary.
            </li></ul>
            <p>This if-and-only-if statement is encoded in a <i>two-level rule</i> like:
            </p>
            <pre>
              "Vowel FRONTING # 1a"
              VowelBack:VowelFront <=> # [ VowelFront: | VowelNeut: | Cons: ]+ %>:  :* _  ;
            </pre>


  <p>Notice that inside the square brackets we have three kinds of symbols: front vowels,
    neutral vowels or consonants &mdash; i.e., everything except the back vowels.

    Another way to write the rule is to create a new set of
    symbols, <b>ConsNonBackVowel</b>, which will contain all symbols except the back
    vowels, and write the rule:
  </p>
  <pre>
    "Vowel FRONTING # 1b"
    VowelBack:VowelFront  <=>  #  ConsNonBackVowel+  %>:  :* _  ;
    </pre>

    The set <b>CVnonback</b> is defined to contain all consonants and all non-back vowels,
    i.e., the front vowels <b>y ä ö</b>, and the neutral vowels <b>i</b> and <b>e</b>.

    The alternative Fronting rules 1a and 1b are completely equivalent.  The only
    difference is that when one of the subsets <b>Cons</b>, <b>VowelFront</b>
    or <b>VowelNeut</b> is modified, we must also remember to modify the new "artificial"
    subset, <b>ConsNonBackVowel</b>, which is somewhat inconvenient.
  


    <a name="From Rule to Transducer"><h2>From Rule to Transducer: Examine the transducer</h2></a>

    <p>
    Note that these rules are <b>compiled</b> by <b>hfst-twolc compiler</b> into actual
    finite state machines (FSTs).  It is possible to print out the transducer, or to graph
    it, using additional HFST tools (see documentation).

    For example, the transducer for the Vowel Harmony rule "Fronting 1b" would look like
    this:
    </p>
    
  <pre>
                     VowelBack  VowelBack  #  ConsNonBackVowel  +  @   
                    VowelFront          @  #                 @  0  @   
               1:            0          1  2                 1  1  1   
               2:            0          1  2                 2  3  2   
               3:            3          0  3                 3  3  3   
  </pre>

    <p>
    This is a machine with three states: 1, 2, 3, which are all accepting states (marked
    by colon after the state name).  An additional state "0" is always a rejecting state.
    The transition table specifies how the machine moves from state to state, while
    reading / writing pairs of symbols on the two tapes: deep tape on top, surface tape on
    the bottom.  We can plot this machine as:
    </p>

    <img src="./Finnish-02/twol-fronting.png" alt="Image:Pictures-simple-lex-1.jpg"
                 width="890" />

    <p>
    The symbol <b>@</b> in this table indicates "any other symbol" &mdash; not covered by
    transitions on the left.

    </p><p>
    We start in state 1, the initial state.  We stay in state 1, until we
    encounter <b>#:#</b> the beginning of the word, at which point we move to state 2
    (nothing before <b>#:#</b> can be seen on input).

    </p><p>
    Once in state 2: we wait for a morpheme boundary <b>+:0</b>, which moves us to state
    3.  Seeing a <b>VowelBack:@</b> with <b>VowelBack</b> on the lexical tape moves us
    back from 2 to 1, where everything is accepted, UNLESS we encounter the
    pair <b>VowelBack:VowelFront</b>, which is rejected.

    </p><p>

      So state 1 can be summarized as: either we having seen nothing yet (still waiting
      for <b>#:#</b>), or we HAVE seen a back vowel, (in which case fronting cannot
      occur).

    </p><p> 

      State 2 can be summarized as: we are between the start of the word and the first
      morpheme boundary &mdash; i.e., we are inside the stem, and making sure we see no
      back vowels.
    
    </p><p> 

      In state 3, we are in the suffix, accepting front and neutral vowels and consonants,
      and more morpheme boundaries.  <b>VowelBack:VowelFront</b> is allowed, but back
      vowel moving to anything else is rejected.

    </p>
  
   

  <a name="HFST Rule Notation"><h2>HFST Rule Notation</h2></a>
  
    <p>
      Each two-level rule must begin with a <b>name</b>, which is a string in double
      quotes, such as <tt>"Vowel Fronting # 1a"</tt>, above.
      
    </p>
  
    <p><b>HFST</b> rules use this notation for regular expressions (REs):
      <ul>
        <li /> <b>a | b</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <i>OR</i> operator,
        
        <li /> <b>a*</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <b>a</b> can appear zero
        or more times,
        
        <li /> <b>a+</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <b>a</b> can appear one
        or more times,

        <li /> <b>(a)</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <b>a</b>
        is <i>optional</i>: can appear zero or one time,

        <li /> <b>[ a | b | ... ]</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; grouping,

        <li /> <b>#</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; word boundary symbol:
        beginning or end,

        <li /> <b>%></b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; morpheme boundary
        symbol:: this is not a special reserved symbol, but is defined inside
        the <b>.lexc</b> file as a <i>multi-character</i> token.

        <li /> <b>_</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; indicates the exact
        position in the environment / context where the rule applies.

      </ul>
      
      In the rule, the left side &mdash; the corresponding pair of input:output symbols
      &mdash; and right side &mdash; the environment of the pair &mdash; are joined by one
      of four operators:
      <ul>

        <li /> <b><=></b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <i>if and only if</i>:
          the corresponding can occur if an only if the context occurs.

          <li /> <b>=></b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <i>only if</i>: the
          correspondence can appear only in this context &mdash; but other
          correspondences can occur in this context as well.
          
          <li /> <b><=</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <i>if</i>: the
            correspondence must always appear in this context &mdash; but the
            correspondence can also occur in other contexts.

          <li /> <b>/<=</b> &nbsp;&nbsp;&mdash;&nbsp;&nbsp; <i>not if</i>: the
             correspondence must never appear in this context &mdash; but it can occur in
             other contexts.

        </ul>
        
    </p><p> The colon separates between the input tape on the left, and the output tape on
        the right.  Either input or output (or both) can be omitted, which means,
        that <i>any</i> symbol can appear on that tape.
                  
        Therefore, <b>[ a | b | c ]+</b> means: an occurrence of <b>a</b> or <b>b</b>
        or <b>c</b> &mdash; <b>[a | b | c ]</b> &mdash; which can be repeated one or more
        times &mdash; <b>+</b>.  A star <b>*</b> indicates a repetition of an expression
        zero or more times.  Thus <b>:*</b> means any input-output symbol pair
        &mdash; <b>:</b> &mdash; appearing zero or more times.

    </p><p> Note that the rule must end with a semicolon.  If you forget the semicolon,
        HFST compiler <b>will crash</b>, and may not even produce a sensible error
        message, so remember to check the semicolons, in case you see an unexplained
        crash.
              
        <!-- Instead <b>HFST</b> does, oddly, allow us to express precisely this meaning,
        but via a completely non-standard RE notation: in <b>HFST</b>, the expression we
        would like to write -- <b>[ a | b | c ]*</b> -- is actually written as <b>a* b*
        c*</b>.  To anyone familiar with RE's this RE has a very different meaning, but
        not in <b>HFST</b>!
            </p>
      <pre><b>Notation:</b> in the current implemenation of <b>HFST</b> rule
        compiler the syntax <b>a* b* c*</b> really means <b>[ a | b | c ]*</b> in
        standard RE notation the syntax <b>[ a | b | c ]*</b> is not recognized
      </pre>
    <p>Thus, the rule we want can be encoded as:
    </p>
    <pre>RULE Vback:Vfront &lt;=&gt; # Cons:@* Vfront:@* Vneut:@* +:0 @:@* ___
      &nbsp;; fronting version-1a
    </pre>
    <p>One can accept this rotational oddity, or work around it in other ways.
      -->

    </p><p>This results in the grammar in directory <b>Finnish-02/</b>.

    </p><p>Note, the lexicon files (<b>.lexc</b>) are back to their simpler form
        as in <b>Finnish-00/</b>.  In particular, <b>finnish.lexc</b> creates no
        new noun or verb states, or <i>sub-lexicons</i>, as we did
        in <b>Finnish-01/</b> &mdash; the effect of vowel harmony is achieved
        instead through this one spelling rule.

    </p><p>Note, at some point you may find that you <i>do</i> need to create a
        new, class for nouns or verbs with a very different <i>paradigm</i>
        &mdash; set of endings that a class of nouns can accept.  We will see
        examples of this in Tutorial, Part II.

        However, that approach should be used with care, because of its potential
        for multiplying out.
      </p>


      <br />
      <hr />

      <div class="editsection" 
           style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=5"
                                                    title="Edit section: Improving the rule
                                                    (***)"></a>]</div>
      <a name="Improving_the_rule_.28.2A.2A.2A.29"></a><h2> Improving the rule
        (Advanced Version ***) </h2> 
    <p>There are a few problems with writing the rule in the above fashion, 
    </p>
    <ul><li> the rule may be too rigid: it specifies the restrictions in both
        directions, which we may need to relax as the grammar grows more complex to
        cover more and more cases.
      </li><!-- <li> 2. (advanced): <b>HFST</b> will not able to figure out some of the
        appropriate loopback states for this rule.
      </li> -->
    </ul>
    <p>For now it works, but you may run into problems with it when your grammar
      will get more complex.
    </p><p>A general practice (also mentioned in the HFST manuals), may be better
      to split up this somewhat complex and rigid rule into a few simpler, more
      flexible rules.
    </p><p>The first split is automatic: <i>by definition</i>, the rule fronting-1
      is equivalent to these two rules:
    </p>
    <pre>
              !! version 2: simpler version: split up:
              "Vowel FRONTING # 2a"
              VowelBack:VowelFront <=  # [ VowelFront: | VowelNeut: | Cons: ]+ %>:  :* _  ; !! 2a
              "Vowel FRONTING # 2b"
              VowelBack:VowelFront  => # [ VowelFront: | VowelNeut: | Cons: ]+ %>:  :* _  ; !! 2b
     </pre>
            <p>On further observation, we notice that rule fronting-2b can be made shorter
            (and simpler):
            </p><p>It is saying that a back vowel must be realized as a front vowel only
            in this environment.  But that is the same thing as saying:
            </p><p>A back vowel must <i>NEVER</i> be realized as a front vowel if we have
              seen a back vowel &mdash; on the <b>surface</b> level &mdash; anywhere
              before the morpheme boundary &mdash; i.e., either in the stem of the word,
              or in an earlier suffix.
            </p>
            <pre>
              "Vowel FRONTING # 3b"
              VowelBack:VowelFront /<=  :VowelBack  :* %>:  _  ; !! 3b
            </pre>
              <p>
                Actually, we don't even need the morpheme boundary: if there was a back
            vowel on the <b>surface</b> tape anywhere earlier, then <b>Vback ← Vfront</b>
            change is forbidden:
            </p>
              <pre>
              "Vowel FRONTING # 3b"
              VowelBack:VowelFront /<=  :VowelBack  :*   _  ; !! 4b
            </pre>
            <p><b>DANGER:</b> However, these two rules together, 2a and 4b, only specify
            that the fronting (the back-to-front change, e.g., <b>a:ä</b>) 
            </p>
            <ul><li> must occur in the  environment of 2a, and 
              </li><li> must not occur in the environment of 4b.
            </li></ul>
            <p>They say nothing about <b>other</b> environments!!!
            </p><p>That means that, if neither of these environments occurs, then a back
            vowel has a choice (!!!): it is free to go either to a back or to a front
            vowel (since feasible pairs exist for both in the alphabet, e.g., <b>a:a</b>
            and <b>a:ä</b>).
            </p><p>We certainly don't want that.  That would accept, e.g., <b>tälö</b> as
            a valid surface form for <b>talo</b>.
            </p><p>Thus we must exclude illegal, arbitrary back-to-front changes.  One way
            to do that is to insist that a back-to-front change can never occur in the
            stem, but only <i>after</i> one (or more) morpheme boundary has been seen:
            </p>
            <pre>
              "Vowel FRONTING # 1c"
              VowelBack:VowelFront  => %>:  :* _  ; !! 1c
            </pre>


            <p>The next modification is rather subtle: for Rule 2a it is better to make a
            change in the environment, from
            </p>
            <pre>
              "Vowel FRONTING # 2a"
              VowelBack:VowelFront <=  # [ VowelFront: | VowelNeut: | Cons: ]+ %>:  :* _  ; !! 2a
            </pre> 
            <p>to
            </p>
            <pre> 
              "Vowel FRONTING # 3a"
              VowelBack:VowelFront <=  # [ :VowelFront | :VowelNeut | :Cons ]+ %>:  :* _  ; 
            </pre> 
            <p>That is, the requirement on the <b>surface</b> tape <b>:VowelFront</b>,
            etc. in 3a is more specific than <b>VowelFront:</b> in 2a.  Rule 3a says:
            vowel fronting must take place as long as we only observed non-back vowels on
            the <b>surface</b> tape, -- i.e., regardless of how these vowels are
            represented on the lexical tape (whether front or back)!
            </p><p>Another way of saying this is: as long as all vowels we saw
            previously on the surface were non-back, they must continue to be non-back,
            even if some of them <i>used to</i> correspond to back vowels on the lexical
            tape.
            </p><p>Again, for the current, tiny lexicon, it would not matter.  But that is
            only because, for now, our lexicon structure is quite trivial:
            </p>
            <pre>
              Stem + Suffix #
            </pre>
            <p>However, you'll see a difference as soon as you allow <i>multiple
            suffixes</i>, e.g.,
            </p>
            <pre>
              Stem + Suffix1 + Suffix2 #
            </pre>
            <p>Consider if we wanted to eventually recognize <b>isä-llä-nsä-kö</b>.  On the
            lexical level, we would wish to represent this as <b>isä-lla-nsa-ko</b>.
            </p><p>However, version 2a would fail to enforce vowel harmony for the
            second suffix <b>-nsa</b>, because <i>a back vowel occurs before it</i> on
            the lexical tape &mdash; namely, the <b>a</b> in suffix <b>-lla</b>.
            </p><p>However, Rule 3a will work, since on the <b>surface</b>
            level <b>-lla</b> is realized as <b>-llä</b>, and no back vowels appear on the
            surface tape prior to <b>a:ä</b> in <b>-nsa</b>.
            </p>



<!--            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=6" title="Edit section: Warnings from HFST">edit</a>]

            </div><a name="Warnings_from_HFST"></a><h2> Warnings from HFST </h2>
            <p>Note: when loading the rules file, <b>HFST</b> may produce (a lot of) warnings.
            </p><p>That's fine.  You can examine the automata created by <b>HFST</b> in the <b>.rul</b> file, and see that it generated  <i>two</i> columns for <b>@:@</b> (this is known as the "loop-back" problem).  Only one of these columns -- the first one -- will be ever seen by the FST.  Therefore, <b>HFST</b> complains.  
            </p><p>To fix the problem, you can
            </p>
            <ul><li> remove the second, redundant <b>@:@</b> column manually in the <b>.rul</b> file
              </li><li> remember to adjust the <i>number of columns</i> in the rule, by subtracting one for the column you removed
            </li></ul>
            <p>and the warnings will stop.
            </p>
-->


            <br />
            <hr />

            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=7" title="Edit section: Illative case: vowel doubling (03)"></a>]</div><a name="Illative_case:_vowel_doubling_.2803.29"></a><h2> Illative case: vowel doubling (03) </h2>
            <ul><li> Let's now add the handling of the Illative case for the nouns we already have in the lexicon:
            </li></ul>
            <pre>
              Base     Illative
              _____    ________
              talo     talo+on
              savu     savu+un
              isä      isä+än
              hissi    hissi+in
            </pre>
            <p>We see that in the Illative case, the final vowel is doubled.
            </p><p>(Note, this still does <i>not</i> handle more complex cases,
            like <b>maa+han</b>, <b>huonee+seen</b>, etc., but those can be handled
            later).
            </p><p>Once again, we could try to handle this through the lexicon (by
            specifying different continuation classes for all these nouns), but that would
            mean <b>multiplying out 8-fold</b>, so let's try to avoid that.

            </p><p>One way to solve this problem is through a <i>trick</i>: introduce a
            new symbol into the alphabet, <b>V</b>, which:
            </p>
            <ul><li> can only appear on the <b>lexical</b> tape; it is a symbol that will
            never appear in a surface word.
              </li><li> has this meaning: double the vowel immediately preceding across a
              morpheme boundary
              </li><li> can map to <b>all</b> the possible vowels on the surface tape:
              i.e., we must add all feasible pairs for <b>V:a V:e V:o V:ä</b>, etc.
            </li></ul>

              <p>Note, by convention, we will introduce new symbols to the alphabet
              (typically for the lexical tape), by using <i>upper-case</i> letters.

                Note that we should add the new symbol to the <b>Vowel</b> set.
                
            </p><p>We must also add eight short rules to handle all possible vowels
            doublings.  This is a little awkward, but there is no other way with finite
            state machines: because they have no memory of the past, you cannot directly
            express a command like "<i>duplicate the vowel you just saw previously</i>".
            </p><p>However, these rules are quite easy, almost identical, and short and
            fast:
            </p>
            <pre>
              "Double a"   V:a  &lt;=&gt;  :a  %>:  _
              "Double e"   V:e  &lt;=&gt;  :e  %>:  _
              "Double i"   V:i  &lt;=&gt;  :i  %>:  _
              "Double o"   V:o  &lt;=&gt;  :o  %>:  _
              "Double u"   V:u  &lt;=&gt;  :u  %>:  _
              "Double y"   V:y  &lt;=&gt;  :y  %>:  _
              "Double ä"   V:ä  &lt;=&gt;  :ä  %>:  _
              "Double ö"   V:ö  &lt;=&gt;  :ö  %>:  _
            </pre>
            <p>As a convenience, HFST lets us abbreviate the above 8 rules as a single
            rule, using the <b>where ... matched</b> clause:
            </p>
            <pre>
              "VOWEL DOUBLING"
              V:Vx  <=>  :Vy  %>:  _  ;
                         where Vx in ( a e i o u y ä ö )
                               Vy in ( a e i o u y ä ö )
                         matched ;
            </pre>
            <p>This results in the grammar in directory <b>Finnish-03/</b>.
            </p><p>Note: we made only a single change to the <b>Noun-Infl-I</b> lexicon:
            added the entry for the Illative case.
            </p>


            <br />
            <hr />

            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=8" title="Edit section: Batch testing and validation"></a>]
            </div><a name="Batch_testing_and_validation"></a><h2> Batch testing and
            validation </h2>
            <p>Note, that by now testing the various noun and verb forms in
            the <b>HFST</b> analyzer becomes tedious: you have to enter many examples each
            time you make a change to the lexicon or the grammar, to make sure nothing is
            broken.
            </p><p>It is easier to create a "validation" file for the
            recognizer, <b>finnish.yaml</b>, and use the HFST validation commands, (see
            HFST documentation).  Simple validation and troubleshooting commands appear in
            the <b>Makefile</b> in each directory. For example, to see all strings
            that the analyzer will recognize, you can use the command:
            </p>
            <pre>
              make check
            </pre>
            which simply runs the HFST command:
            <pre>
              hfst-fst2strings finnish.lexc-analyzer.hfst
            </pre>


<!--
            HFST&gt;compare recognize Finnish-03/finnish.rec
              <p>or you can abbreviate this (the <b>.rec</b> extension is the default for
              the <b>compare recognize</b> command):
            </p>
            <pre>HFST&gt;com rec Finnish-03/finnish
            </pre>
            <p>Please see the file <b>finnish.rec</b> to see how it should be formatted.
            Each entry contains the surface form, followed on the next line by the
            expected analysis:
            </p>
            <pre>talossa
              talo+ssa     [N(house)+Ine]

              talossä
              *** NONE ***

              isllä
              is+lla     [N(father)+Ade]

              ...
            </pre>
            <p>The <b>compare recognize</b> command goes through all examples in the
            validation file and reports any inconsistencies.
            </p><p>Note, that it is important to validate not only sufrace words that the
            recognizer should accept, like <b>talossa</b>, <b>savuun</b>, <b>palavat</b>,
            etc.  but also that incorrect strings will be rejected such
            as <b>isälla</b>, <b>taloan</b>, <b>kysyvat</b>, etc.
            </p><p>Note also, that when a valid form is accepted, <b>compare recognize</b>
            prints nothing.  When an invalid form is rejected, HFST <i>always</i> produces
            output (namely <b>*** NONE ***</b>), even if this aggrees with the the
            validation file which says that the form should be rejected.
            </p>
-->


            <br />
            <hr />

            <div class="editsection"
            style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=9"
            title="Edit section: Final -i/-e- alternation in nouns
            (04)"></a>]
            </div><a name="Final_-i.2F-e-_alternation_in_nouns_.2804.29"></a><h2> Final
            -i/-e- alternation in nouns (04) </h2>
            <ul><li> Add nouns that end in <b>-i</b> &mdash; the "native" nouns &mdash;
            but that behave differently from those we have in the lexicon so far (such
            as <i>hissi</i>):
            </li></ul>
            <pre>
              Noun: kivi, ovi
            </pre>
            <p>These nouns form a new class of nouns, since the stem-final <b>-i</b>
            changes to <b>-e-</b> in the oblique cases (<i>oblique</i> cases are all cases
            that are not nominative).  In linguistic terms, this distinguishes the
            "native" vs. the "borrowed" nouns that end in <b>-i</b>.
            </p><p>This class can also be implemented without creating an actual new set
            of endings &mdash; since the case endings are exactly the same as
            for <b>talo</b>, <b>isä</b>, etc., only the stem <i>vowel</i> is different,
            depending on whether the case is nominative or oblique.

            </p><p>A neat way to do that is, again, by introducing a new, special symbol
              to the alphabet: let's define <b>I</b> (capital letter <b>i</b>) to be the
              "deep" shape of the stem-final vowel in these native Finnish nouns.

              Note that we should also add <b>I</b> to <b>Vowel</b>, <b>VowelNeutral</b>
              subsets, for completeness, so rules and lexicons work when they are extended
              in the future.

              <h4>A note about Tapes</h4>
              Notice, this deep level is intermediate &mdash; it is between the lexical
              level and the surface level.  In the lexicon, these <b>I</b> symbols will
              appear on the output tape (the input being the Lexical Tape), but in the
              rules, the <b>I</b> symbols will appear on the input tape (the Surface
              Tape).  When the lexicon is composed with the rules, this middle "deep" tape
              disappears, and only the Lexical (input) and Surface (output) Tapes remain.

              (Note, as we said before, this is the tape order for a generator, and that
              these will need to be flipped to obtain an analyzer.)
              
            </p><p>Then, we state that <b>I</b> can be realized only through one of two
            feasible pairs:
            </p>
            <pre>
              I:i    for nominative case
              I:e    otherwise (oblique cases)
            </pre>
            <p>This will also require a rule that says that <b>I</b> is realized as <b>i</b> iff it is word-final:
            </p>
            <pre>
              "Native -i nouns"
              I:i  <=>  _  %>:*  # ;
            </pre>
            <p>Now we can add <b>kivi</b> and <b>ovi</b> to the <b>Noun-stems</b> lexicon,
            as <i>SURFACE</i> forms <b>kivI, ovI</b>.
            </p><p>This results in the grammar in directory <b>Finnish-04/</b>.

            </p><p>Note that this required <i>no changes</i> to the <b>Noun-Infl-I</b>
            lexicon.
            </p>
            <ul><li> <b>Batch validation:</b>
            </li></ul>
            <p>Note: after compiling the new lexicon and rules, we can do a quick batch
            validation &mdash; all previously checked words must still pass the
            validation.
            </p>
            <p>Then the newly tested forms for <b>kivi</b> and <b>ovi</b> can be
            validated, and note that vowel harmony still works correctly: <b>kive-llä</b>
            and <b>ove-lla</b>.
            </p>


            <br />
            <hr />

            <div class="editsection"
            style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=10"
            title="Edit section: Consonant Gradation: tt-&amp;gt;t
                   (05)"></a>]
            </div><a name="Consonant_Gradation:_tt-.3Et_.2805.29"></a><h2> Consonant
            Gradation: tt &rightarrow; t (05) </h2>
            <ul><li> Add nouns and verbs to the lexicon that contain some consonant
            gradation
            </li></ul>
            <pre>
              Nouns                   Verbs
              _____________           __________________
              katto / katon           nukuttaa / nukutan
              tyttö / tytön           heittää / heitän
            </pre>
            <p>Note that this required no changes to the <b>Noun-Infl-I</b> or
            the <b>Verb-Infl-I</b> lexicons.
            </p>
            <ul><li> Add morpho-phonological rules for handling the consonant gradation tt
            &rightarrow; t.
            </li></ul>
            <p>We need to observe under what conditions the surface form has the strong
            grade (<b>tt</b>) and under what conditions the weak grade (<b>t</b>):
            </p>
            <pre>
              STRONG:            WEAK:
              _______            __________________________________________
              katto              kato-n, kato-lla, kato-ksi, ...
              katto-na           
              nukutta-vat        nukuta-n, nukuta-t, nukuta-mme, nukuta-tte
            </pre>
            <p>To summarize: the grade of the consonant is strong if the <i>syllable is
            open</i> &mdash; i.e., the syllable ends in a vowel.  If we indicate the
            syllabic boundary with a bar | then our data looks like this:
            </p>
            <pre>
              STRONG:            WEAK:
              _______            _____________________________________
              kat|to|            ka|ton, ka|tol|la, ka|tok|si, ...
              kat|to|na
              nu|kut|ta|vat      nu|ku|tan, nu|ku|tat, nu|ku|tam|me, nu|ku|tat|te ...
            </pre>
              <p>Note: syllable boundary is very different from the morpheme boundary, and
            is totally independent of it!  Therefore, we can model this change as follows:
            </p>
            <p>
            <ul><li> 1. On the lexical tape, we will <b>always</b> say that the grade is
            strong: <b>tt</b>
              </li><li> 2. On the surface tape, we will say that the grade is strong iff
              the <b>syllable is open</b>: i.e., after the stem vowel,
                <ul><li> the word ends, or
                  </li><li> there is a consonant followed by a vowel &mdash; <i>NOT</i> by
                  two consonants.
                </li></ul>
            </li></ul>
            </p>
            <p>Equivalently, we can use the inverse of rule 2 instead, which is:
            </p><p>
            <ul><li> 2a. On the surface tape, we will say that the grade is weak iff the
            syllable is closed: i.e., after the stem vowel, there is a morpheme boundary,
            plus a consonant, after which:
                <ul><li> the word ends, or
                  </li><li> there is another consonant -- <i>NOT</i> a vowel.
                </li></ul>
            </li></ul>
            <pre>
              "Consonant gradation tt->t"
              t:0  <=>  t:t  _  Vowel %>: Cons  [ Cons | # ] ;  !! tt-t gradation version 1
            </pre>

              <!-- RULE  t:0  &lt;=&gt;  t ___ Vow  +:0  Cons [ Cons | # ] &nbsp;;; tt-&gt;t gradation version 1 -->

            </p><p>Note, we must remember to define the set of symbols
              called <b>Vowel</b>, and place all vowels into it, including the special
              symbol <b>V</b>, which we made for vowel doubling !
            </p>

            <br />
            <hr />

            <div class="editsection"
            style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=11"
            title="Edit section: Relaxing the rule
            (***)"></a>]

            </div><a name="Relaxing_the_rule_.28.2A.2A.2A.29"></a><h2> Relaxing the rule
            (***) </h2>

              <p>Just as in the case of the vowel harmony rule, this will be too rigid for
              when we will wish to expand the grammar.  For example, we will wish to
              implement nouns with <i>multiple suffixes</i>, such as the
              negative <b>-ton-/-ttom-</b> suffix, in <b>katoton</b>, <b>katottoman</b>,
              etc., see <a href="./morphology-tutorial-2.html" title="Morphology Tutorial,
              Part II">Morphology Tutorial, Part II</a>.  Then, this
              alternation <b>tt-&gt;t</b> will need to take place in a new
              environment: <i>inside</i> the suffix morpheme <b>-ton-/-ttom-</b>, which
              contains no morpheme boundary between the vowel and the consonant.  To
              accommodate this, we will have to break the overly rigid <b>tt-&gt;t</b>
              gradation rule into pieces (which says the change may occur <i>ONLY</i> in
              this environment!)
            </p><p><b>The basic strategy</b> for simplifying the rule is this: try to
            </p>
            <ul><li> treat each of the two directions <b>&lt;=</b>
            and <b>=&gt;</b> <i>separately</i>, and
              </li><li> treat each side of the environment (left and right) separately.
            </li></ul>
            <p>As we modify the environment of the rule, the main thing to keep in mind is
            these basic principles:
            </p>
            <ul><li> <b>&lt;= +specialize</b>: adding elements to the environment of a
            &lt;= rule <b>specializes</b> the rule (makes it apply in fewer cases)
              </li><li> <b>=&gt; +generalize</b>: adding elements to the environment of a
              =&gt; rule <b>generalizes</b> the rule (makes it apply in more cases)
            </li></ul>
            <p>As an obvious consequence,
            </p>
            <ul><li> <b>&lt;= -generalize</b>:removing elements from the environment of a &lt;= rule <b>generalizes</b> the rule
              </li><li> <b>=&gt; -specialize</b>:removing elements from the environment of
              a =&gt; rule <b>specializes</b> the rule
            </li></ul>
            <p>This is not obvious, and may require some thought to clarify.  Work with
            abstract example rules:
            </p>
            <ul><li> a:b  &lt;=  ___ e
              </li><li> a:b  &lt;=  ___ e f
            </li></ul>
            <p>It is easy to see that the shorter rule is more general.  On the other
            hand, between
            </p>
            <ul><li> a:b   =&gt; ___ e
              </li><li> a:b   =&gt; ___ e f
            </li></ul>
            <p>the <i>longer rule is more general</i>.  To see why, observe finally that
            these last two rules are respectively equivalent to
            </p>
            <ul><li> a:b  /&lt;=  NOT (___ e)
              </li><li> a:b  /&lt;=  NOT (___ e f)
            </li></ul>
            <p>and the longer rule is more general: it forbids the change in more
            environments.  For example, if the environment is ___ e x, then the shorter
            rule does not apply, whereas the longer rule does (because ___ e x is NOT ___
            e f).
            </p>


            <hr />

            <p>That is the theory and philosophy.  Now we begin to apply it.  Again, we
            start with the simplest split, into two directions:
            </p>
            <pre>
              "Gradation tt->t: 2a"  t:0  <=   t:t  _  Vowel %>: Cons  [ Cons | # ] ; 
              "Gradation tt->t: 2b"  t:0   =>  t:t  _  Vowel %>: Cons  [ Cons | # ] ;
            </pre>
              <p>Now, version "2a: IF" gives just one environment where the
                weakening <i>must</i> occur.  We will later add other environments -- for
                handling suffixes like <b>-ton-/-ttom-</b> -- where the morpheme boundary
                is not present, but the weakening must still occur.
              </p><p>In the other direction, Version "2b: ONLY IF" is certainly too rigid:
                it says the weakening may take place <i>ONLY</i> in this environment.  We
                should anticipate that we will want to allow the grade to weaken
                in <i>other</i> environments as well, not <i>only</i> in closed syllables.
              </p><p>For example, <b>ka|to|ton</b> the second syllable appears to
                be <i>open</i> on the surface, yet the grade of <b>t</b> is still weak!

              </p><p>Can we remove "2b: ONLY IF" altogether?  Certainly not, because "2a:
                IF" controls only when the weakening <i>MUST</i> occur; it says nothing
                about where it is allowed to occur.  In fact, if we remove "2b: ONLY IF",
                the weakening will be allowed to occur absolutely <i>anywhere</i>.  That
                is, without "2b: ONLY IF", the machine would accept "<b>kato</b>" and even
                "<b>kao</b>", and analyze both of these surface forms as "<b>katto</b>" on
                the lexical level, which is absurd.
              </p><p>We should therefore specify under what conditions the weakening is
                disallowed.  The following rules will replace "2b: ONLY IF".
              </p><p>We will start with one simple restriction: allow only
                the <i>SECOND</i> of two consecutive <b>t</b> symbols on the lexical tape
                to disappear during the weakening.
              </p>
              <pre>
                "Gradation tt->t: 2c"  t:0  /<=   _ t: ; 
            </pre>
            <p>This says that the first <b>t</b> in a pair of <b>t</b> symbols must never
              disappear.  Note that the second <b>t</b> in the environment may be mapped
              to <i>ANYTHING</i> on the surface level (i.e., this will mean
              either <b>t</b> or <b>0</b>, for now, since these are the only two feasible
              pairs for <b>t</b> on the surface level, at the moment.  But there will be
              more alternatives coming later!)
              </p><p>
              This is a good start, but the machine will still accept invalid forms like 
            </p>
            <pre>
              heitävät 
              kato     
            </pre>
              <p>
                now with the <i>second</i> <b>t</b> deleted -- since deleting the second
                <b>t</b> is not restricted in any way.  So, we should restrict the
                deletion of the second <b>t</b>:
              </p>
              <pre>
                "Gradation tt->t: 2d"  t:t  <=  _ Vowel: (%>:)  [ # |  Vowel: |  Cons: Vowel: ] ;
              </pre>
  <p>
    Recall that The notation <b>(%>:)</b> means that the morpheme boundary
    is <i>optional</i>.
              </p><p>This rule says that <b>t</b> is unchanged &mdash; it does not
  undergo <i>any</i> weakening &mdash; if it appears in an <b>OPEN</b> syllable,
  viewed <i>from the LEXICAL</i> level: i.e., if on the lexical level it is followed by a
  vowel, plus an optional morpheme boundary, plus:
</p>
            <ul>
              <li> either the end of word, as in <b>katto</b>, 
              </li>
              <li> a vowel, as in <b>sattua</b> or <b>heittää</b>, 
              </li>
              <li> or a lexical consonant followed by a lexical vowel, as
              in <b>katto+na</b>
              </li>
            </ul>
            <!--
           <p>These two rules can be combined, but that is not necessary.  It is easier
           for HFST to translate two shorter rules than one longer rule (please
           see <b>HFST</b> manuals).
           </p>
           <pre>RULE  t:t  &lt;=  ___ Vow:@  (+:0)  [ # | Cons:@  Vow:@ ] &nbsp;;; tt-&gt;t gradation 2d-e
           </pre>
           -->

              <p>Now <b>kato</b> and <b>heitävät</b> are rejected.
            </p><p>However, surface <b>kesän</b> is still accepted as
            lexical <b>kestä+n</b>&nbsp;!
            </p><p>That suggests that we must treat <b>t</b> after <b>s</b> specially
            &mdash; it can never be removed:
            </p>
              <pre>
                "Gradation tt->t: 2d"     t:t  <=  _ Vowel: (%>:)  [ # | Vowel: | Cons:  Vowel: ] ;
                                                    s: _  ;
              </pre>
              <p>Note, how we can simply <i>append additional environments</i> to an
                existing rule.
              </p><p> One last problem: with these rules, some rather odd words will still
                be accepted as valid, e.g., <b>heittä</b> and <b>heitä</b>.
              <b>(Why?)</b>
            </p><p>To see why they are accepted, try recognizing them, you'll see that
            they are analyzed as having a final <b>-t</b> suffix (the one we use for 2nd
            person singular).
            </p><p>(Why?  Try to see how the rules accept this.  If you don't succeed, try
            the HFST command <b>make check</b> above, to see all acceptable strings.)
            </p><p>To avoid this problem, we must limit where <b>t</b> is permitted to
            disappear:
            </p> 
              <pre> 
                "Gradation tt->t: 2e"      t:0   =>  t _ ;  !! delete only SECOND t 
            </pre>
            <p>This simply says, that if the <b>t</b> (on the lexical tape) ever
            disappears, then it <i>MUST BE</i> the second <b>t</b> of a pair of
            consecutive lexical <b>t</b> symbols, and nowhere else.
            </p><p>This results in the grammar <b>finnish-v2.twol/</b> in
            directory <b>Finnish-05/</b>.
              </p><p>To summarize, we end up with the following set of rules:
            </p>
            <pre>!! tt-&gt;t gradation
              "Gradation tt->t: 2a"     t:0   <=  t:t  _  Vowel %>: Cons  [ Cons | # ] ;     !! 2a: must remove second t in closed syllable 
              "Gradation tt->t: 2c"     t:0  /<=  _ t: ;                                     !! 1c: first t must never be removed 
              "Gradation tt->t: 2d"     t:t   <=  _ Vowel: (%>:)  #  ; 
                                                  _ Vowel: (%>:)  Vowel:  ; 
                                                  _ Vowel: (%>:)  Cons:  Vowel:  ; 
                                               s: _  ;                                       !! t unchanged in open syllable or after s 
              "Gradation tt->t: 2e"     t:0   =>  t _ ;                                      !! only the SECOND t can be removed 
            </pre>
            <p>This may seem like a lot of rules, to replace the single rule version 1.
            But these rules are substantially simpler, and it will turn out to be much
            more flexible, much easier to generalize these rules to other many kinds of
            weakening that a lexical <b>t</b> can undergo.
            </p>


            <br />
            <hr />

            <div class="editsection"
            style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=12"
            title="Edit section: Weakening t-&amp;gt;d
            (06)"></a>]

            </div><a name="Weakening_t-.3Ed_.2806.29"></a><h2> Weakening t &rightarrow; d
            (06)</h2>
            <p>Now we handle another type of weakening: the gradation <b>t &rightarrow; d</b>.
            </p>
            <pre>
              pöytä / pöydän
              löytää / löydän
            </pre>

                <p>The best strategy at this point is to simply
                  <ul>
                    <li />add these two stems to the Noun and Verb lexicons, and
                    <li />run <b>make</b> and <b>make check</b>, to see
                    how the current analyzer will (mis)handle these stems.
                  </ul>
                  It is clear that it is unable to handle the weakening of <b>t</b> here.
                </p><p> We will try to re-use the rules we wrote for <b>tt-&gt;t</b> as
                  much as possible for this weakening.  The rules 2c, 2d and 2e specify
                  the conditions when <b>t</b> must NOT weaken &mdash; and that will cover
                  both <b>tt-&gt;t0</b> weakening as well as <b>t-&gt;d</b> weakening.
            </p><p>First, we need a rule that will substitute for 2a, above:
            </p>
            <pre>
              "Gradation tt->t: 2a"     t:0   <=  t:t  _  Vowel %>: Cons  [ Cons | # ] ;     !! must remove second t in closed syllable
            </pre>
            <p>This can be done as follows:
            </p>
            <ol>
              <li> add a <i>new feasible pair</i> for <b>t:d</b>
              </li>
              <li> create a rule similar to 2a, that specifies when the
              weakening <b>t:d</b> <i>MUST</i> occur:
              </li>
            </ol>
            <p>We can't just say:
            </p>
            <pre>
              "Gradation t->d: 6a"      t:d   <=  _  Vowel %>: Cons  [ Cons | # ] ;          !! must weaken t in closed syllable 
            </pre>
            <p>because that will conflict with Rule 2a above.  What we want to say
            is: <b>t:d</b> must occur if it is not preceded by <b>t</b>.

            </p><p>In any case, <b>HFST</b> does not allow us to say <b>~t</b> to
            mean <i>NOT t</i>.  We could make a set containing everything except <b>t</b>,
            called <b>NotT</b>, and make the rule:
            </p>
            <pre> 
              "Gradation t->d: 6a"      t:d   <=  NotT: _  Vowel %>: Cons  [ Cons | # ] ;    !! must weaken t in closed syllable 
            </pre> 
            <p>But we should not do that for several reasons:
            </p>
            <ol><li> <b>t:d</b> is too restrictive: we will actually weaken <b>t</b>
            to <b>l</b> if preceded by <b>l</b>, to <b>r</b> if preceded by <b>r</b>, and
            to <b>n</b> if preceded by <b>n</b>.  We will need more flexibility in the
            future!
              </li><li> Such a solution is not elegant. And every time we need extend the
              alphabet, we will need to update the set <b>NotT</b>.
            </li></ol>

            <p>Notice, in fact, that we are already quite close to having the
            functionality we are trying to achieve, without creating any new rules: all we
            need to do is make rule 2a <i>LESS</i> restrictive!

            </p><p>Creating a feasible pair will make <b>t:d</b> a <i>possibility</i>.
            Now we can try to make the following change:
            </p>
            <pre>
              !! REPLACE tt-&gt;t gradation rule 2a: 6a: must weaken t in closed syllable
              "Gradation t->d: 6a"      t:Tweak   &lt;=  _  Vowel %>: Cons  [ Cons | # ] ; 
            </pre>
              <p>
                We define <b>Tweak</b> to be a subset, containing the <i>WEAK</i> grades
            of <b>t</b>.  For now it will contain just <b>d</b> and <b>0</b> (but we can
            later expand it to include also <b>l</b> for <b>lt-&gt;ll</b>, and <b>r</b>
            for <b>rt-&gt;rr</b>)
            </p><p>(Think about why!)

            </p><p>Note that we still have rule 2e from above, which says that a
            lexical <b>t</b> can be weakened to <b>0</b>, ONLY if this lexical <b>t</b> is
            preceded by another <b>t</b>, and nowhere else.
            </p>
              <pre> 
              "Gradation tt-&gt;t: 2e"     t:0   =&gt;  t _ ;                                !! only the SECOND t can be removed 
              </pre>
              <p>It functions as it did before.  In addition, now this rule also
            implicitly implies that in environments not covered by this rule, whenever
            some other rule forces a weakening of <b>t</b> it will have to
            be <b>t-&gt;d</b>.  That may be a bit too much, since we will later need other
            kinds of weakenings.  So better make it <i>explicit</i>.  In what environments
            do we allow <b>t-&gt;d</b>?  If it is preceded by a vowel, or by <b>h</b>, as
            in <b>tähti/tähden</b>.
            </p>
            <pre>
              "Gradation t-&gt;d: 6f"     t:d   =&gt;  [Vow | h]  _ ;                        !! legal environments for t:d 
            </pre>
            <p>This results in the grammar in directory <b>Finnish-06/</b>.

            </p><p><b>(***)</b>
            </p><p>!!! Note 1: by adding the new feasible pair <b>t:d</b> we inadvertently
            broke rule 1c, above, which said that we allow only the SECOND one of two
            consecutive <b>t</b> symbols on the lexical level to disappear during the
            weakening.
            </p>
            <pre>
              RULE  t:0  /&lt;=  ___ t: &nbsp;;; tt-&gt;t gradation 1c
            </pre>
            <p>Now since <b>t:d</b> is another possible alternative weakening, rule 1c
            must be strengthened to disallow <b>t:d</b> as well.
            </p><p>(Question: Why?  
            </p><p>Think about it before looking at the answer, below.)
            </p><p>(Answer: 
            </p><p>because otherwise it will accept illegal surface forms,
            like <b>nukudtavat</b> as lexical <b>nukuttavat</b>.)
            </p><p>The slightly stronger rule might look like this:
            </p>
            <pre>
              RULE  t:Tweak  /&lt;=  ___ t: &nbsp;;; tt-&gt;t gradation 2c
            </pre>
            <p>Of course, an equivalent way of saying this is:
            </p>
            <pre>
              RULE  t:t       &lt;=  ___ t: &nbsp;;; tt-&gt;t gradation 2c
            </pre>
            <p>!!! Note 2: the new rule, 5a, broke rule 1f, which we had made earlier to prevent <b>t</b> weakening after <b>s</b>:
            </p>
            <pre>
              RULE  t:t       &lt;=  s: ___ &nbsp;;; tt-&gt;t gradation 1f
            </pre>
            <p>So now <b>kestän</b> is rejected anyway (by 5a).
            </p><p>This should be fixed.  (Left as an exercise.  One way, is, again to
            create a set of everything except <b>s</b> and put that in the left
            environment of <b>t:Tweak</b> rule.  Not elegant, but may be necessary
            because <b>HFST</b> supports no negation for now...  A better way is to
            specify explicitly a slightly narrower set of environments, in which the
            weakening must occur, and which excludes environments with a
            preceding <b>s</b>.)
            </p>


            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=13" title="Edit section: Left for the reader"></a>]

            </div><a name="Left_for_the_reader"></a><h2> Left for the reader </h2>
            <ul><li> Handle additionally, for the verbs already in the lexicon:
            </li></ul>
            <pre> Imperative, 2nd person singular:
              kysyä / kysy  (easy)
              pitää / pidä  (harder)
            </pre>
            <hr />

            <div class="editsection" style="float:right;margin-left:5px;">[<a href="/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I&amp;action=edit&amp;section=14" title="Edit section: Closing Note"></a>]

            </div><a name="Closing_Note"></a><h2> Closing Note </h2>

              <p>The resulting simple grammar is certainly far from being complete by any
              means.  There remain a very large number of features that still need to be
              incorporated into this grammar before it can be used for real morphological
              analysis.
            </p><p>There is no single "correct" answer to solving these kinds of
            morphological problems.  Most morphological phenomena can be modeled in
            several different ways, with different rules.  In comparing different rules
            for a given morphological phenomenon, we typically care not only about
            correctness, but we pay attention to the rules' generality, and also to their
            simplicity, and elegance.
            </p><p>The purpose of this tutorial is not to specify "correct solutions", but
            to introduce the student to the process of designing morphological rules and
            lexicons.
            </p><p>Lastly, the grammar we have designed so far leaves some gaps: it will
            still
            </p>
            <ul><li> accept some illegal surface forms, and
              </li><li> reject valid words (those involving <b>-st-</b> as in <b>kestän</b>).
            </li></ul>
            <p>It is left as an exercise to identify these and correct them, by adjusting
            the rules.  (Solutions in Tutorial, Part II).
            </p>

            <hr/>

            <!-- Saved in parser cache with key
            wikidb:pcache:idhash:1571-0!1!0!0!!en!2 and timestamp 20061127120512


            Retrieved from "<a href="http://sysdb.cs.helsinki.fi/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I">http://sysdb.cs.helsinki.fi/~tkt_plus/nlp-wiki/index.php?title=Morphology_Tutorial%2C_Part_I</a>"
            -->

	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
    </div>
    <!-- Served by sbz-17 in 0.330 secs. -->
</body></html>
